# frozen_string_literal: true

default_platform(:ios)
fastlane_require 'dotenv'
fastlane_require 'git'

UI.user_error!('Please run fastlane via `bundle exec`') unless FastlaneCore::Helper.bundler?

USER_ENV_FILE_PATH = File.join(Dir.home, '.wcios-env.default')
SECRETS_DIR = File.join(Dir.home, '.configure', 'woocommerce-ios', 'secrets')
PROJECT_ENV_FILE_PATH = File.join(SECRETS_DIR, 'project.env')

GITHUB_REPO = 'woocommerce/woocommerce-ios'
DEFAULT_BRANCH = 'trunk'

# Constants
PROJECT_ROOT_FOLDER = File.dirname(File.expand_path(__dir__))
RESOURCES_FOLDER = File.join(PROJECT_ROOT_FOLDER, 'WooCommerce', 'Resources')
PUBLIC_CONFIG_FILE = File.join(PROJECT_ROOT_FOLDER, 'config', 'Version.Public.xcconfig')
RELEASE_NOTES_PATH = File.join(RESOURCES_FOLDER, 'release_notes.txt')
RELEASE_NOTES_SOURCE_PATH = File.join(PROJECT_ROOT_FOLDER, 'RELEASE-NOTES.txt')
FASTLANE_DIR = File.join(PROJECT_ROOT_FOLDER, 'fastlane')
DERIVED_DATA_DIR = File.join(FASTLANE_DIR, 'DerivedData')
SCREENSHOTS_DIR =  File.join(FASTLANE_DIR, 'screenshots')
FASTLANE_METADATA_FOLDER = File.join(FASTLANE_DIR, 'metadata')
WORKSPACE_PATH = File.join(PROJECT_ROOT_FOLDER, 'WooCommerce.xcworkspace')
IOS_LOCALES = %w[ar de-DE en-US es-ES fr-FR he id it ja ko nl-NL pt-BR ru sv tr zh-Hans zh-Hant].freeze
SIMULATOR_VERSION = '15.5' # For screenshots
SCREENSHOTS_SCHEME = 'WooCommerceScreenshots'
SCREENSHOT_DEVICES = [
  'iPhone 11 Pro Max',
  'iPhone 8 Plus',
  'iPad Pro (12.9-inch) (2nd generation)',
  'iPad Pro (12.9-inch) (3rd generation)'
].freeze

# Instantiate versioning classes
VERSION_CALCULATOR = Fastlane::Wpmreleasetoolkit::Versioning::MarketingVersionCalculator.new
VERSION_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::FourPartVersionFormatter.new
BUILD_CODE_FORMATTER = Fastlane::Wpmreleasetoolkit::Versioning::FourPartBuildCodeFormatter.new
BUILD_CODE_KEY = 'VERSION_LONG'
VERSION_FILE = Fastlane::Wpmreleasetoolkit::Versioning::IOSVersionFile.new(xcconfig_path: PUBLIC_CONFIG_FILE)

APP_STORE_VERSION_BUNDLE_IDENTIFIER = 'com.automattic.woocommerce'
# Registered in our main account, for development and App Store
MAIN_BUNDLE_IDENTIFIERS = [
  APP_STORE_VERSION_BUNDLE_IDENTIFIER,
  "#{APP_STORE_VERSION_BUNDLE_IDENTIFIER}.storewidgets",
  "#{APP_STORE_VERSION_BUNDLE_IDENTIFIER}.notificationcontentextension",
  "#{APP_STORE_VERSION_BUNDLE_IDENTIFIER}.watchkitapp",
  "#{APP_STORE_VERSION_BUNDLE_IDENTIFIER}.watchkitapp.widgets"
].freeze

ALPHA_VERSION_BUNDLE_IDENTIFIER = 'com.automattic.alpha.woocommerce'
# Registered in our Enterprise account, for App Center / Prototype Builds
ALPHA_BUNDLE_IDENTIFIERS = MAIN_BUNDLE_IDENTIFIERS.map do |id|
  id.gsub(APP_STORE_VERSION_BUNDLE_IDENTIFIER, ALPHA_VERSION_BUNDLE_IDENTIFIER)
end.freeze

# Shared options to use when invoking `gym` / `build_app`.
#
# - `manageAppVersionAndBuildNumber: false` prevents `xcodebuild` from bumping
#   the build number when extracting an archive into an IPA file. We want to
#   use the build number we set!
COMMON_EXPORT_OPTIONS = { manageAppVersionAndBuildNumber: false }.freeze

TEST_SCHEME = 'WooCommerce'

CONCURRENT_SIMULATORS = 2

# List of `.strings` files manually maintained by developers (as opposed to being automatically extracted from the code)
# which we will merge into the main `Localizable.strings` file imported by GlotPress, then extract back once we download the translations.
#
# Each `.strings` file to be merged/extracted is associated with a prefix to add to the keys, used to avoid conflicts and differentiate the source of the copies.
#
# See calls to `ios_merge_strings_files` and `ios_extract_keys_from_strings_files` for usage.
#
# Note that, yes, we currently have only one file, but it's still worth defining this constant because it's used across more than one lane, as described above.
#
MANUALLY_MAINTAINED_STRINGS_FILES = {
  File.join(RESOURCES_FOLDER, 'en.lproj', 'InfoPlist.strings') => 'infoplist.'
}.freeze

# URL of the GlotPress project containing the strings used in the app
GLOTPRESS_APP_STRINGS_PROJECT_URL = 'https://translate.wordpress.com/projects/woocommerce/woocommerce-ios/'
# URL of the GlotPress project containing App Store Connect metadata
GLOTPRESS_APP_STORE_METADATA_PROJECT_URL = 'https://translate.wordpress.com/projects/woocommerce/woocommerce-ios/release-notes/'

# List of locales used for the app strings (GlotPress code => `*.lproj` folder name`)
#
# TODO: Replace with `LocaleHelper` once provided by release toolkit (https://github.com/wordpress-mobile/release-toolkit/pull/296)
GLOTPRESS_TO_LPROJ_APP_LOCALE_CODES = {
  'ar' => 'ar',         # Arabic
  'de' => 'de',         # German
  'es' => 'es',         # Spanish
  'fr' => 'fr',         # French
  'he' => 'he',         # Hebrew
  'id' => 'id',         # Indonesian
  'it' => 'it',         # Italian
  'ja' => 'ja',         # Japanese
  'ko' => 'ko',         # Korean
  'nl' => 'nl',         # Dutch
  'pt-br' => 'pt-BR',   # Portuguese (Brazil)
  'ru' => 'ru',         # Russian
  'sv' => 'sv',         # Swedish
  'tr' => 'tr',         # Turkish
  'zh-cn' => 'zh-Hans', # Chinese (China)
  'zh-tw' => 'zh-Hant'  # Chinese (Taiwan)
}.freeze

# Mapping of all locales which can be used for AppStore metadata (Glotpress code => AppStore Connect code)
#
# TODO: Replace with `LocaleHelper` once provided by release toolkit (https://github.com/wordpress-mobile/release-toolkit/pull/296)
GLOTPRESS_TO_ASC_METADATA_LOCALE_CODES = {
  'ar' => 'ar-SA',
  'de' => 'de-DE',
  'es' => 'es-ES',
  'fr' => 'fr-FR',
  'he' => 'he',
  'id' => 'id',
  'it' => 'it',
  'ja' => 'ja',
  'ko' => 'ko',
  'nl' => 'nl-NL',
  'pt-br' => 'pt-BR',
  'ru' => 'ru',
  'sv' => 'sv',
  'tr' => 'tr',
  'zh-cn' => 'zh-Hans',
  'zh-tw' => 'zh-Hant'
}.freeze

ASC_KEY_PATH = File.join(SECRETS_DIR, 'app_store_connect_fastlane_api_key.json')

# Use this instead of getting values from ENV directly
# It will throw an error if the requested value is missing
def get_required_env(key)
  UI.user_error!("Environment variable '#{key}' is not set. Have you setup #{USER_ENV_FILE_PATH} correctly?") unless ENV.key?(key)
  ENV.fetch(key)
end

before_all do |lane|
  # Skip these checks/steps for test lane (not needed for testing)
  next if lane == :test_without_building

  # Check for Release Toolkit updates
  check_for_toolkit_updates unless is_ci || ENV['FASTLANE_SKIP_TOOLKIT_UPDATE_CHECK']

  # Check that the env files exist
  UI.user_error!("~/.wcios-env.default not found: Please copy env/user.env-example to #{USER_ENV_FILE_PATH} and fill in the values") unless is_ci || File.file?(USER_ENV_FILE_PATH)
  UI.user_error!('project.env not found: Make sure your configuration is up to date with `rake dependencies`') unless File.file?(PROJECT_ENV_FILE_PATH)

  setup_ci
end

platform :ios do
  ########################################################################
  # Environment
  ########################################################################
  Dotenv.load(USER_ENV_FILE_PATH)
  Dotenv.load(PROJECT_ENV_FILE_PATH)

  ########################################################################
  # Release Lanes
  ########################################################################
  #####################################################################################
  # start_code_freeze
  # -----------------------------------------------------------------------------------
  # This lane executes the steps planned on code freeze
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane start_code_freeze [skip_confirm:<skip confirm>]
  #
  # Example:
  # bundle exec fastlane start_code_freeze
  # bundle exec fastlane start_code_freeze skip_confirm:true
  #####################################################################################
  desc 'Creates a new release branch from the current trunk'
  lane :start_code_freeze do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    # Check out the up-to-date default branch, the designated starting point for the code freeze
    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)

    UI.important <<-MESSAGE

      Code Freeze:
      • New release branch from #{DEFAULT_BRANCH}: release/#{release_version_next}
      • Current release version and build code: #{release_version_current} (#{build_code_current}).
      • New release version and build code: #{release_version_next} (#{build_code_code_freeze}).

    MESSAGE
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Create the release branch
    UI.message('Creating release branch...')
    Fastlane::Helper::GitHelper.create_branch("release/#{release_version_next}", from: DEFAULT_BRANCH)
    UI.success("Done! New release branch is: #{git_branch}")

    # Bump the release version and build code and write it to the `xcconfig` file
    UI.message('Bumping release version and build code...')
    VERSION_FILE.write(
      version_short: release_version_next,
      version_long: build_code_code_freeze
    )
    commit_version_bump
    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")

    new_version = release_version_current

    extract_release_notes_for_version(
      version: new_version,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH,
      extracted_notes_file_path: RELEASE_NOTES_PATH
    )
    ios_update_release_notes(
      new_version: new_version,
      release_notes_file_path: RELEASE_NOTES_SOURCE_PATH
    )

    UI.important('Pushing changes to remote and configuring the release on GitHub')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    copy_branch_protection(
      repository: GITHUB_REPO,
      from_branch: DEFAULT_BRANCH,
      to_branch: "release/#{new_version}"
    )
    set_milestone_frozen_marker(
      repository: GITHUB_REPO,
      milestone: new_version
    )

    check_pods_references
  end

  #####################################################################################
  # complete_code_freeze
  # -----------------------------------------------------------------------------------
  # This lane executes the initial steps planned on code freeze
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane complete_code_freeze [skip_confirm:<skip confirm>]
  #
  # Example:
  # bundle exec fastlane complete_code_freeze
  # bundle exec fastlane complete_code_freeze skip_confirm:true
  #####################################################################################
  desc 'Creates a new release branch from the current trunk'
  lane :complete_code_freeze do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important("Completing code freeze for: #{release_version_current}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    update_app_store_strings

    generate_strings_file_for_glotpress

    push_to_git_remote(tags: false)

    trigger_beta_build(branch_to_build: "release/#{release_version_current}")

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{release_version_current}-code-freeze-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{release_version_current} code freeze to #{DEFAULT_BRANCH}"
    )
  end

  # Updates the `AppStoreStrings.pot` file with the latest content from the `release_notes.txt` files and the other text sources.
  #
  # @option [String] version The current `x.y[.z]` version of the app. Optional. Used to derive the `vx.y[.z]-whats-new` key to use in the `.pot` file.
  #
  desc 'Updates the AppStoreStrings.pot file with the latest data'
  lane :update_app_store_strings do |options|
    source_metadata_folder = File.join(FASTLANE_DIR, 'appstoreres', 'metadata', 'source')

    files = {
      whats_new: RELEASE_NOTES_PATH,
      app_store_subtitle: File.join(source_metadata_folder, 'subtitle.txt'),
      app_store_desc: File.join(source_metadata_folder, 'description.txt'),
      app_store_keywords: File.join(source_metadata_folder, 'keywords.txt'),
      'app_store_promo_text' => File.join(source_metadata_folder, 'app_store_promo_text.txt'),
      'app_store_screenshot-1' => File.join(source_metadata_folder, 'promo_screenshot_1.txt'),
      'app_store_screenshot-2' => File.join(source_metadata_folder, 'promo_screenshot_2.txt'),
      'app_store_screenshot-3' => File.join(source_metadata_folder, 'promo_screenshot_3.txt'),
      'app_store_screenshot-4' => File.join(source_metadata_folder, 'promo_screenshot_4.txt'),
      'app_store_screenshot-5' => File.join(source_metadata_folder, 'promo_screenshot_5.txt')
    }

    ios_update_metadata_source(
      po_file_path: File.join(RESOURCES_FOLDER, 'AppStoreStrings.pot'),
      source_files: files,
      release_version: options.fetch(:version, release_version_current)
    )
  end

  #####################################################################################
  # new_beta_release
  # -----------------------------------------------------------------------------------
  # This lane updates the release branch for a new beta release. It will update the
  # current release branch by default.
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane new_beta_release [skip_confirm:<skip confirm>]
  #
  # Example:
  # bundle exec fastlane new_beta_release
  # bundle exec fastlane new_beta_release skip_confirm:true
  #####################################################################################
  desc 'Updates a release branch for a new beta release'
  lane :new_beta_release do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    ensure_git_branch_is_release_branch

    UI.important <<-MESSAGE

      Current build code: #{build_code_current}
      New build code: #{build_code_next}

    MESSAGE
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Download the latest translations from GlotPress
    download_localized_strings_and_metadata_from_glotpress
    lint_localizations

    # Bump the build code
    UI.message('Bumping build code...')
    ensure_git_branch_is_release_branch
    VERSION_FILE.write(version_long: build_code_next)
    commit_version_bump
    UI.success("Done! New Build Code: #{build_code_current}")

    UI.important('Pushing changes to remote and triggering the beta build')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    trigger_beta_build(branch_to_build: "release/#{release_version_current}")

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{build_code_current}-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{build_code_current} into #{DEFAULT_BRANCH}"
    )
  end

  #####################################################################################
  # new_hotfix_release
  # -----------------------------------------------------------------------------------
  # This lane creates the release branch for a new hotfix release.
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane new_hotfix_release [skip_confirm:<skip confirm>] [version:<version>]
  #
  # Example:
  # bundle exec fastlane new_hotfix_release version:10.6.1
  # bundle exec fastlane new_hotfix_release skip_confirm:true version:10.6.1
  #####################################################################################
  desc 'Creates a new hotfix branch for the given version:x.y.z. The branch will be cut from the tag x.y of the previous release'
  lane :new_hotfix_release do |options|
    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    new_version = options[:version] || UI.input('Version number for the new hotfix?')

    # Parse the provided version into an AppVersion object
    parsed_version = VERSION_FORMATTER.parse(new_version)
    build_code_hotfix = BUILD_CODE_FORMATTER.build_code(version: parsed_version)
    previous_version = VERSION_FORMATTER.release_version(VERSION_CALCULATOR.previous_patch_version(version: parsed_version))

    # Check versions
    UI.important <<-MESSAGE

      New hotfix version: #{new_version}
      New build code: #{build_code_hotfix}
      Branching from tag: #{previous_version}

    MESSAGE
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Check tags
    UI.user_error!("Version #{new_version} already exists! Abort!") if git_tag_exists(tag: new_version)
    UI.user_error!("Version #{previous_version} is not tagged! A hotfix branch cannot be created.") unless git_tag_exists(tag: previous_version)

    # Create the hotfix branch
    UI.message('Creating hotfix branch...')
    Fastlane::Helper::GitHelper.create_branch("release/#{new_version}", from: previous_version)
    UI.success("Done! New hotfix branch is: #{git_branch}")

    # Bump the hotfix version and build code and write it to the `xcconfig` file
    UI.message('Bumping hotfix version and build code...')
    VERSION_FILE.write(
      version_short: new_version,
      version_long: build_code_hotfix
    )
    commit_version_bump

    # Push the newly created hotfix branch
    push_to_git_remote(tags: false)

    UI.success("Done! New Release Version: #{release_version_current}. New Build Code: #{build_code_current}")
  end

  #####################################################################################
  # finalize_hotfix_release
  # -----------------------------------------------------------------------------------
  # This lane finalizes the hotfix branch.
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane finalize_hotfix_release
  #####################################################################################
  desc 'Performs the final checks and triggers a release build for the hotfix in the current branch'
  lane :finalize_hotfix_release do |options|
    ensure_git_branch_is_release_branch

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    hotfix_version = release_version_current

    UI.important("Triggering hotfix build for version: #{hotfix_version}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: "release/#{hotfix_version}")

    # Retrieve the current non-hotfix release version
    Fastlane::Helper::GitHelper.checkout_and_pull(DEFAULT_BRANCH)
    non_hotfix_release_version = release_version_current

    # Create an intermediate branch
    Fastlane::Helper::GitHelper.checkout_and_pull("release/#{hotfix_version}")
    new_intermediate_branch_name = "merge/#{hotfix_version}-hotfix-into-release-#{non_hotfix_release_version}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: "release/#{non_hotfix_release_version}",
      title: "Merge #{hotfix_version} hotfix into release/#{non_hotfix_release_version}"
    )
  end

  #####################################################################################
  # finalize_release
  # -----------------------------------------------------------------------------------
  # This lane finalize a release: updates store metadata, bump final version number,
  # remove branch protection and close milestone, then trigger the final release on CI
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane finalize_release [skip_confirm:<skip confirm>] [version:<version>]
  #
  # Example:
  # bundle exec fastlane finalize_release
  # bundle exec fastlane finalize_release skip_confirm:true
  #####################################################################################
  desc 'Trigger the final release build on CI'
  lane :finalize_release do |options|
    UI.user_error!('To finalize a hotfix, please use the `finalize_hotfix_release` lane instead') if release_is_hotfix?
    ensure_git_branch_is_release_branch

    # Verify that there's nothing in progress in the working copy
    ensure_git_status_clean

    UI.important("Finalizing release: #{release_version_current}")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    # Don't check translation coverage in CI
    check_translation_progress_all unless is_ci
    download_localized_strings_and_metadata_from_glotpress
    lint_localizations

    # Bump the build code
    UI.message('Bumping build code...')
    VERSION_FILE.write(version_long: build_code_next)
    commit_version_bump
    UI.success("Done! New Build Code: #{build_code_current}")

    # Wrap up
    version = release_version_current
    begin
      remove_branch_protection(
        repository: GITHUB_REPO,
        branch: "release/#{version}"
      )
      set_milestone_frozen_marker(
        repository: GITHUB_REPO,
        milestone: version,
        freeze: false
      )
      close_milestone(
        repository: GITHUB_REPO,
        milestone: version
      )
    rescue StandardError => e
      error_message = <<-MESSAGE
        Error removing branch protection or finalization of milestone `#{version}`: #{e.message}
        - If this is a retry of the lane, the milestone might have already been closed and this error is expected.
          Just ensure the branch protection for `release/#{version}` is no more and that the milestone `#{version}` is indeed closed.
        - If this is the first run of the lane, please investigate the error.
      MESSAGE

      UI.error(error_message)
      buildkite_annotate(style: 'warning', context: 'finalize-release-error-milestone', message: error_message) if is_ci
    end

    # Start the build
    UI.important('Pushing changes to remote and triggering the release build')
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    push_to_git_remote(tags: false)

    trigger_release_build(branch_to_build: "release/#{version}")

    # Create an intermediate branch
    new_intermediate_branch_name = "merge/#{release_version_current}-final-into-#{DEFAULT_BRANCH}"
    Fastlane::Helper::GitHelper.create_branch(new_intermediate_branch_name)

    # Push up the intermediate branch
    push_to_git_remote(tags: false)

    create_release_management_pull_request(
      base_branch: DEFAULT_BRANCH,
      title: "Merge #{release_version_current} final into #{DEFAULT_BRANCH}"
    )
  end

  lane :check_translation_progress_all do
    check_translation_progress_strings
    check_translation_progress_release_notes
  end

  lane :check_translation_progress_strings do
    UI.message('Checking app strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      abort_on_violations: false
    )
  end

  lane :check_translation_progress_release_notes do
    UI.message('Checking release notes strings translation status...')
    check_translation_progress(
      glotpress_url: GLOTPRESS_APP_STORE_METADATA_PROJECT_URL,
      abort_on_violations: false
    )
  end

  #####################################################################################
  # trigger_beta_build
  # -----------------------------------------------------------------------------------
  # This lane triggers a beta build on CI
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane trigger_beta_build [branch_to_build:<branch_name>]
  #
  #####################################################################################
  lane :trigger_beta_build do |options|
    trigger_buildkite_release_build(
      branch: options[:branch_to_build],
      beta: true
    )
  end

  #####################################################################################
  # trigger_release_build
  # -----------------------------------------------------------------------------------
  # This lane triggers a stable release build on CI
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane trigger_release_build [branch_to_build:<branch_name>]
  #
  #####################################################################################
  lane :trigger_release_build do |options|
    trigger_buildkite_release_build(
      branch: options[:branch_to_build],
      beta: false
    )
  end

  #####################################################################################
  # build_and_upload_to_app_store_connect
  # -----------------------------------------------------------------------------------
  # This lane builds the app and upload it for external distribution
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_and_upload_to_app_store_connect [skip_confirm:<skip confirm>] [beta_release:<intermediate beta?>]
  #
  # Example:
  # bundle exec fastlane build_and_upload_to_app_store_connect
  # bundle exec fastlane build_and_upload_to_app_store_connect skip_confirm:true
  # bundle exec fastlane build_and_upload_to_app_store_connect beta_release:true
  #####################################################################################
  desc 'Builds and uploads for distribution to the App Store'
  lane :build_and_upload_to_app_store_connect do |options|
    unless options[:skip_prechecks]
      # Verify that there's nothing in progress in the working copy
      ensure_git_status_clean unless is_ci

      ios_build_preflight(derived_data_path: DERIVED_DATA_DIR)
      xcversion # Ensure we're using the right version of Xcode, defined in `.xcode-version` file
    end

    ensure_sentry_installed

    UI.important("Building version #{release_version_current} (#{build_code_current}) and uploading to TestFlight")
    unless options[:skip_confirm] || UI.confirm('Do you want to continue?')
      UI.user_error!("Terminating as requested. Don't forget to run the remainder of this automation manually.")
    end

    build_for_app_store_connect

    sentry_upload_dsym(
      auth_token: get_required_env('SENTRY_AUTH_TOKEN'),
      org_slug: 'a8c',
      project_slug: 'woocommerce-ios',
      dsym_path: File.join(PROJECT_ROOT_FOLDER, 'WooCommerce.app.dSYM.zip')
    )
    sh('cd .. && rm WooCommerce.app.dSYM.zip')

    archive_zip_path = File.join(File.dirname(Dir.pwd), 'WooCommerce.xarchive.zip')
    zip(path: lane_context[SharedValues::XCODEBUILD_ARCHIVE], output_path: archive_zip_path)

    version = options[:beta_release] ? build_code_current : release_version_current
    create_release(
      repository: GITHUB_REPO,
      version: version,
      release_notes_file_path: RELEASE_NOTES_PATH,
      release_assets: archive_zip_path.to_s,
      prerelease: options[:beta_release]
    )
    sh("rm #{archive_zip_path}")

    upload_to_testflight(
      api_key_path: ASC_KEY_PATH,
      # Wait 2 hours for the build to process then time out
      wait_processing_timeout_duration: 7200,
      changelog: File.read(RELEASE_NOTES_PATH),
      distribute_external: true,
      # If there is a build waiting for beta review, we want to reject that so the new build can be submitted instead
      reject_build_waiting_for_review: true,
      groups: ['Internal a8c beta testers', 'Public Beta Testers']
    )
    sh('cd .. && rm WooCommerce.ipa')
  end

  desc 'Builds for distribution to the App Store'
  lane :build_for_app_store_connect do
    appstore_code_signing

    gym(
      scheme: 'WooCommerce',
      workspace: WORKSPACE_PATH,
      clean: true,
      export_team_id: get_required_env('EXT_EXPORT_TEAM_ID'),
      export_options: { **COMMON_EXPORT_OPTIONS, method: 'app-store' }
    )
  end

  #####################################################################################
  # build_and_upload_prototype_build
  # -----------------------------------------------------------------------------------
  # This lane builds the app and upload it for adhoc testing
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_and_upload_prototype_build [version_long:<version_long>]
  #
  # Example:
  # bundle exec fastlane build_and_upload_prototype_build
  # bundle exec fastlane build_and_upload_prototype_build build_number:123
  #####################################################################################
  desc 'Builds and uploads a prototype build (Enterprise distribution)'
  lane :build_and_upload_prototype_build do
    ensure_sentry_installed
    xcversion # Ensure we're using the right version of Xcode, defined in `.xcode-version` file

    build_for_prototype_build

    appcenter_upload(
      api_token: get_required_env('APPCENTER_API_TOKEN'),
      owner_name: 'automattic',
      owner_type: 'organization',
      app_name: 'WooCommerce-Installable-Builds',
      destinations: 'Collaborators',
      notify_testers: false
    )

    sentry_upload_dsym(
      auth_token: get_required_env('SENTRY_AUTH_TOKEN'),
      org_slug: 'a8c',
      project_slug: 'woocommerce-ios',
      dsym_path: './build/WooCommerce.app.dSYM.zip'
    )

    # The build code used in the Enterprise build has a different format that the App Store one.
    # We cannot use the standard build_code_current method but have to read it directly.
    build_code = Xcodeproj::Config.new(File.new(PUBLIC_CONFIG_FILE)).to_hash[BUILD_CODE_KEY]
    UI.message("Successfully built and uploaded prototype build `#{build_code}` to App Center.")

    return if ENV['BUILDKITE_PULL_REQUEST'].nil?

    # PR Comment
    comment_body = prototype_build_details_comment(
      app_display_name: 'WooCommerce iOS',
      app_center_org_name: 'automattic'
    )
    comment_on_pr(
      project: GITHUB_REPO,
      pr_number: Integer(ENV.fetch('BUILDKITE_PULL_REQUEST')),
      reuse_identifier: 'prototype-build-link',
      body: comment_body
    )
  end

  desc 'Builds a prototype build (Enterprise build)'
  lane :build_for_prototype_build do
    alpha_code_signing

    # Get the current build version, and update it if needed
    versions = Xcodeproj::Config.new(File.new(PUBLIC_CONFIG_FILE)).to_hash
    build_number = generate_prototype_build_number
    UI.message("Updating build version to #{build_number}")
    versions[BUILD_CODE_KEY] = build_number
    new_config = Xcodeproj::Config.new(versions)
    new_config.save_as(Pathname.new(PUBLIC_CONFIG_FILE))

    gym(
      scheme: 'WooCommerce Alpha',
      workspace: WORKSPACE_PATH,
      export_method: 'enterprise',
      clean: true,
      output_directory: 'build',
      export_team_id: get_required_env('INT_EXPORT_TEAM_ID'),
      export_options: {
        **COMMON_EXPORT_OPTIONS,
        method: 'enterprise',
        iCloudContainerEnvironment: 'Production'
      }
    )
  end

  #####################################################################################
  # build_for_testing
  # -----------------------------------------------------------------------------------
  # This lane builds the app for testing
  # -----------------------------------------------------------------------------------
  # Usage:
  # bundle exec fastlane build_for_testing
  #####################################################################################
  desc 'Build for Testing'
  lane :build_for_testing do |options|
    xcversion # Ensure we're using the right version of Xcode, defined in `.xcode-version` file

    run_tests(
      workspace: WORKSPACE_PATH,
      scheme: TEST_SCHEME,
      derived_data_path: 'DerivedData',
      build_for_testing: true,
      device: options[:device],
      deployment_target_version: options[:ios_version]
    )
  end

  # Upload the localized metadata (from `fastlane/metadata/`) to App Store Connect
  #
  # @option [Boolean] with_screenshots (default: false) If true, will also upload the latest screenshot files to ASC
  # @option [Boolean] skip_confirm If true, the HTML preview will be bypassed
  #
  desc 'Upload the localized metadata to App Store Connect, optionally including screenshots.'
  lane :update_metadata_on_app_store_connect do |options|
    # Skip screenshots by default. The naming is "with" to make it clear that
    # callers need to opt-in to adding screenshots. The naming of the deliver
    # (upload_to_app_store) parameter, on the other hand, uses the skip verb.
    with_screenshots = options.fetch(:with_screenshots, false)
    skip_screenshots = !with_screenshots

    upload_to_app_store(
      app_identifier: APP_STORE_VERSION_BUNDLE_IDENTIFIER,
      app_version: release_version_current,
      team_id: '299112',
      skip_binary_upload: true,
      screenshots_path: File.join(FASTLANE_DIR, 'promo_screenshots'),
      skip_screenshots: skip_screenshots,
      overwrite_screenshots: true, # won't have effect if `skip_screenshots` is true
      phased_release: true,
      precheck_include_in_app_purchases: false,
      api_key_path: ASC_KEY_PATH,
      force: options[:skip_confirm]
    )
  end

  ########################################################################
  # Screenshot Lanes
  ########################################################################
  desc 'Build Screenshots'
  lane :build_screenshots do
    # Ensure we're using the latest Pods
    cocoapods(verbose: true)

    # Ensure we're using the right version of Xcode, defined in `.xcode-version` file
    xcversion

    scan(
      workspace: WORKSPACE_PATH,
      scheme: SCREENSHOTS_SCHEME,
      build_for_testing: true,
      derived_data_path: DERIVED_DATA_DIR
    )
  end

  desc 'Take Screenshots'
  lane :take_screenshots do |options|
    # Ensure we're using the right version of Xcode, defined in `.xcode-version` file
    xcversion

    # By default, clear previous screenshots
    languages = IOS_LOCALES

    languages &= options[:languages].split(',') unless options[:languages].nil?

    devices = SCREENSHOT_DEVICES

    devices &= options[:devices].split(',') unless options[:devices].nil?

    UI.user_error!("Unable to run on devices: \"#{devices}\"") if devices.empty?

    puts "Creating screenshots for #{languages} on #{devices}"

    # Erase the simulator between runs in order to get everything back to a default state
    rebuild_screenshot_devices

    capture_ios_screenshots(
      scheme: SCREENSHOTS_SCHEME,

      localize_simulator: true,
      languages: languages,

      devices: devices,

      # Don't rebuild the app for every new locale / device type, and specify where to find the binaries
      test_without_building: true,
      derived_data_path: DERIVED_DATA_DIR,

      # Where should the screenshots go, and should we delete them before starting?
      output_directory: SCREENSHOTS_DIR,

      # Output the simulator logs for debugging
      buildlog_path: File.join(FASTLANE_DIR, 'logs'),
      output_simulator_logs: true,
      result_bundle: true,
      namespace_log_files: true,

      concurrent_simulators: true,

      # Explicitly set the iOS version to ensure we match the created simulators
      ios_version: SIMULATOR_VERSION,

      # Erase the simulator prior to booting the app
      erase_simulator: true,

      # Retry a few times if something is a little flaky
      number_of_retries: 3,

      # But fail completely after those 3 retries
      stop_after_first_error: true,

      # Allow the caller to invoke dark mode
      dark_mode: options[:mode].to_s.downcase == 'dark',

      # Make the status bar pretty
      override_status_bar: true
    )
  end

  desc 'Create Screenshots Locally'
  lane :screenshots do |options|
    FileUtils.rm_f(SCREENSHOTS_DIR)

    build_screenshots(options)
    take_screenshots(options.merge({ mode: 'light' }))
    take_screenshots(options.merge({ mode: 'dark' }))
  end

  desc 'Rebuild Screenshot Devices'
  lane :rebuild_screenshot_devices do
    require 'simctl'

    SimCtl.list_devices.each do |device|
      next unless SCREENSHOT_DEVICES.include? device.name

      puts "Deleting #{device.name} because it already exists."
      device.delete
    end

    SCREENSHOT_DEVICES.each do |device|
      runtime = SimCtl.runtime(name: "iOS #{SIMULATOR_VERSION}")
      devicetype = SimCtl.devicetype(name: device)

      SimCtl.create_device(device, devicetype, runtime)
    end
  end

  desc 'Create Screenshot Summary'
  lane :create_screenshot_summary do
    fastlane_require 'snapshot'

    # Provide enough information to bootstrap the configuration and generate the HTML report
    Snapshot.config = FastlaneCore::Configuration.create(
      Snapshot::Options.available_options,
      {
        workspace: WORKSPACE_PATH,
        scheme: SCREENSHOTS_SCHEME
      }
    )

    Snapshot::ReportsGenerator.new.generate
  end

  desc 'Downloads localized strings and App Store Connect metadata from GlotPress'
  lane :download_localized_strings_and_metadata_from_glotpress do
    download_localized_strings_from_glotpress
    download_localized_metadata_from_glotpress
  end

  desc 'Downloads localized `.strings` from GlotPress'
  lane :download_localized_strings_from_glotpress do
    ios_download_strings_files_from_glotpress(
      project_url: GLOTPRESS_APP_STRINGS_PROJECT_URL,
      locales: GLOTPRESS_TO_LPROJ_APP_LOCALE_CODES,
      download_dir: RESOURCES_FOLDER
    )
    git_commit(
      path: File.join(RESOURCES_FOLDER, '*.lproj', 'Localizable.strings'),
      message: 'Update app translations – `Localizable.strings`',
      allow_nothing_to_commit: true
    )

    # Redispatch the appropriate subset of translations back to the manually-maintained `.strings`
    # files that we merged at the `complete_code_freeze` time via `ios_merge_strings_files`
    modified_files = ios_extract_keys_from_strings_files(
      source_parent_dir: RESOURCES_FOLDER,
      target_original_files: MANUALLY_MAINTAINED_STRINGS_FILES
    )
    git_commit(
      path: modified_files,
      message: 'Update app translations – Other `.strings`',
      allow_nothing_to_commit: true
    )
  end

  desc 'Downloads localized metadata for App Store Connect from GlotPress'
  lane :download_localized_metadata_from_glotpress do
    metadata_directory = FASTLANE_METADATA_FOLDER

    # FIXME: We should make the `fastlane/metadata/default/release_notes.txt` path be the source of truth for the original copies in the future.
    # (will require changes in the `update_app_store_strings` lane, the Release Scenario, the MC tool to generate the announcement post…)
    #
    # In the meantime, just copy the file to the right place for `deliver` to find, i.e. to the `default` pseudo-locale which is used as fallback
    FileUtils.cp(RELEASE_NOTES_PATH, File.join(metadata_directory, 'default', 'release_notes.txt'))

    # FIXME: Replace this with a call to the future replacement of `gp_downloadmetadata` once it's implemented in the release-toolkit (see paaHJt-31O-p2).
    locales_map = GLOTPRESS_TO_ASC_METADATA_LOCALE_CODES
    target_files = {
      "v#{release_version_current}-whats-new": { desc: 'release_notes.txt', max_size: 4000 },
      app_store_name: { desc: 'name.txt', max_size: 30 },
      app_store_subtitle: { desc: 'subtitle.txt', max_size: 30 },
      app_store_desc: { desc: 'description.txt', max_size: 4000 },
      app_store_keywords: { desc: 'keywords.txt', max_size: 100 }
    }

    gp_downloadmetadata(
      project_url: GLOTPRESS_APP_STORE_METADATA_PROJECT_URL,
      target_files: target_files,
      locales: locales_map,
      download_path: metadata_directory
    )
    files_to_commit = [File.join(metadata_directory, '**', '*.txt')]

    # Ensure that none of the `.txt` files in `en-US` would accidentally override our originals in `default`
    target_files.values.map { |h| h[:desc] }.each do |file|
      en_file_path = File.join(metadata_directory, 'en-US', file)
      if File.exist?(en_file_path)
        UI.user_error!("File `#{en_file_path}` would override the same one in `#{metadata_directory}/default`, but `default/` is the source of truth. " \
                       + "Delete the `#{en_file_path}` file, ensure the `default/` one has the expected original copy, and try again.")
      end
    end

    # Ensure even empty locale folders have an empty `.gitkeep` file (in case we don't have any translation at all ready for some locales)
    locales_map.each_value do |locale|
      gitkeep = File.join(metadata_directory, locale, '.gitkeep')
      next if File.exist?(gitkeep)

      FileUtils.mkdir_p(File.dirname(gitkeep))
      FileUtils.touch(gitkeep)
      files_to_commit.append(gitkeep)
    end

    # Commit
    git_add(
      path: files_to_commit,
      shell_escape: false
    )
    git_commit(
      path: files_to_commit,
      message: 'Update metadata translations',
      allow_nothing_to_commit: true
    )
  end

  desc 'Download App Store Translations'
  lane :download_app_store_translations do
    # FIXME: `download_localized_metadata_from_glotpress` makes this lane almost redundant,
    # but we need to carefully adjust the screenshots metadata locations to complete the process.
    # See https://github.com/woocommerce/woocommerce-ios/issues/6987
    files = {

      # Metadata fields
      'app_store_desc' => { desc: 'description.txt' },
      'app_store_keywords' => { desc: 'keywords.txt' },
      'app_store_subtitle' => { desc: 'subtitle.txt' },
      'app_store_promo_text' => { desc: 'promotional_text.txt' },
      "v#{release_version_current}-whats-new" => { desc: 'whats_new.txt' },

      # Screenshots
      'app_store_screenshot-1' => { desc: 'app_store_screenshot_1.txt' },
      'app_store_screenshot-2' => { desc: 'app_store_screenshot_2.txt' },
      'app_store_screenshot-3' => { desc: 'app_store_screenshot_3.txt' },
      'app_store_screenshot-4' => { desc: 'app_store_screenshot_4.txt' },
      'app_store_screenshot-5' => { desc: 'app_store_screenshot_5.txt' }
    }

    metadata_locales = GLOTPRESS_TO_ASC_METADATA_LOCALE_CODES

    gp_downloadmetadata(
      project_url: GLOTPRESS_APP_STORE_METADATA_PROJECT_URL,
      target_files: files,
      locales: metadata_locales,
      source_locale: 'en-US',
      download_path: FASTLANE_METADATA_FOLDER
    )

    # Copy appstoreres (screenshot-related) txt files into `en-US`
    en_us_path = File.join(Dir.pwd, 'metadata', 'en-US')
    FileUtils.mkdir_p(en_us_path)

    [
      'promo_screenshot_1.txt',
      'promo_screenshot_2.txt',
      'promo_screenshot_3.txt',
      'promo_screenshot_4.txt',
      'promo_screenshot_5.txt'
    ].each do |filename|
      source = File.join(Dir.pwd, 'appstoreres', 'metadata', 'source', filename)
      destination = File.join(en_us_path, filename)
      FileUtils.cp(source, destination)
    end

    # Never store review information (it contains passwords and PII)
    review_info_path = File.join(Dir.pwd, 'metadata', 'review_information')
    FileUtils.remove_dir(review_info_path) if File.directory?(review_info_path)
  end

  desc 'Create Promo Screenshots'
  lane :create_promo_screenshots do |options|
    unless Fastlane::Helper::GitHelper.has_git_lfs?
      UI.user_error!('LFS not enabled – unable to generate promo screenshots. Run `git lfs install && git lfs fetch && git lfs pull` to fix this.')
    end

    # Create a copy of the files to work with – this ensures that if we're doing multiple
    # screenshot generation tasks close together, we can keep reusing the same source files
    original_screenshot_directory = File.join(Dir.pwd, 'screenshots')
    metadata_directory = File.join(Dir.pwd, 'metadata')
    output_directory = File.join(Dir.pwd, '/promo_screenshots')

    # Run screenshots generator tool
    promo_screenshots(
      orig_folder: original_screenshot_directory,
      metadata_folder: metadata_directory,
      output_folder: output_directory,
      force: options[:force]
    )
  end

  ########################################################################
  # Configure Lanes
  ########################################################################

  # Downloads all the required certificates and profiles for both production and internal distribution builds.
  # Optionally, it can create any new necessary certificate or profile.
  #
  # @option [Boolean] readonly (default: true) Whether to only fetch existing certificates and profiles, without generating new ones.
  lane :update_certs_and_profiles do |options|
    alpha_code_signing(options)
    appstore_code_signing(options)
  end

  # Downloads all the required certificates and profiles the enterprise build.
  # Optionally, it can create any new necessary certificate or profile.
  #
  # @option [Boolean] readonly (default: true) Whether to only fetch existing certificates and profiles, without generating new ones.
  private_lane :alpha_code_signing do |options|
    readonly = options.fetch(:readonly, true)

    if readonly
      # In readonly mode, we can use the API key
      api_key_path = ASC_KEY_PATH
    else
      # The Enterprise account APIs do not support authentication via API key.
      # If we want to modify data (readonly = false) we need to authenticate manually.
      prompt_user_for_app_store_connect_credentials
      # We also need to pass no API key path, otherwise Fastlane will give
      # precedence to that authentication mode.
      api_key_path = nil
    end

    match(
      type: 'enterprise',
      team_id: get_required_env('INT_EXPORT_TEAM_ID'),
      app_identifier: ALPHA_BUNDLE_IDENTIFIERS,
      readonly: readonly,
      api_key_path: api_key_path
    )
  end

  # Downloads all the required certificates and profiles the production build.
  # Optionally, it can create any new necessary certificate or profile.
  #
  # @option [Boolean] readonly (default: true) Whether to only fetch existing certificates and profiles, without generating new ones.
  private_lane :appstore_code_signing do |options|
    match(
      type: 'appstore',
      team_id: get_required_env('EXT_EXPORT_TEAM_ID'),
      app_identifier: MAIN_BUNDLE_IDENTIFIERS,
      readonly: options.fetch(:readonly, true),
      api_key_path: ASC_KEY_PATH
    )
  end

  ########################################################################
  # Helper Lanes
  ########################################################################
  desc 'Run release preflight checks'
  lane :release_preflight do
    configure_validate
  end

  # Generates the `.strings` file to be imported by GlotPress, by parsing source code (using `genstrings` under the hood).
  #
  #
  # @option [Boolean] skip_commit (default: false) If true, does not commit the changes made to the `.strings` file.
  #
  # @called_by complete_code_freeze
  #
  desc 'Updates the main `Localizable.strings` file — that will be imported by GlotPress — from code and `Info.plist` files'
  lane :generate_strings_file_for_glotpress do |options|
    cocoapods

    en_lproj_path = File.join(RESOURCES_FOLDER, 'en.lproj')
    ios_generate_strings_file_from_code(
      paths: [
        'WooCommerce/',
        'Pods/WordPress*/',
        'Storage/Storage/',
        'Networking/Networking/',
        'Hardware/Hardware/'
      ],
      exclude: [
        '*Vendor*',
        '**/AppLocalizedString.swift',
        'WooCommerce/WooCommerceTests/**' # Some unit tests include localized strings, but we don't want to crowd GlotPress with them
      ],
      routines: ['AppLocalizedString'],
      output_dir: en_lproj_path
    )

    # Merge various manually-maintained `.strings` files into the previously generated `Localizable.strings` so their extra keys are also imported in GlotPress.
    #
    # Note: We will re-extract the translations back during `download_localized_strings_from_glotpress` (via a call to `ios_extract_keys_from_strings_files`)
    ios_merge_strings_files(
      paths_to_merge: MANUALLY_MAINTAINED_STRINGS_FILES,
      destination: File.join(en_lproj_path, 'Localizable.strings')
    )

    next if options.fetch(:skip_commit, false)

    git_commit(
      path: en_lproj_path,
      message: 'Freeze strings for localization',
      allow_nothing_to_commit: true
    )
  end

  desc 'Lint the `.strings` files'
  lane :lint_localizations do
    ios_lint_localizations(input_dir: RESOURCES_FOLDER, allow_retry: true)
  end

  def write_file(path, contents)
    FileUtils.rm_f(path)
    file = File.new(path, 'w')
    file.write(contents)
  rescue IOError => e
    UI.crash(e)
  ensure
    file&.close
  end
end

########################################################################
# Test Lanes
########################################################################
#####################################################################################
# test_without_building
# -----------------------------------------------------------------------------------
# This lane runs tests without building the app.
# It requires a prebuilt xctestrun file and simulator destination where the tests will be run.
# -----------------------------------------------------------------------------------
# Usage:
# bundle exec fastlane test_without_building [name:<Partial name of the .xctestrun file>]
#
# Example:
# bundle exec fastlane test_without_building name:UITests
#####################################################################################
desc 'Run tests without building'
lane :test_without_building do |options|
  # Find the referenced .xctestrun file based on its name
  build_products_path = File.expand_path('DerivedData/Build/Products/', File.dirname(Dir.pwd))

  xctestrun_path = Dir.glob(File.join(build_products_path, '*.xctestrun')).select do |e|
    e.include?(options[:name])
  end.first

  UI.user_error!("Unable to find .xctestrun file at #{xctestrun_path}") unless !xctestrun_path.nil? && File.exist?(xctestrun_path)

  inject_buildkite_analytics_environment(xctestrun_path: xctestrun_path) if buildkite_ci?

  # Only run UI tests in parallel.
  # At the time of writing with Xcode 14.3, we need to explicitly set this value despite using test plans that configure parallelism.
  parallel_testing_value = options[:name] == 'UITests'

  run_tests(
    workspace: WORKSPACE_PATH,
    scheme: TEST_SCHEME,
    device: options[:device],
    reset_simulator: true,
    parallel_testing: parallel_testing_value,
    concurrent_workers: CONCURRENT_SIMULATORS,
    max_concurrent_simulators: CONCURRENT_SIMULATORS,
    test_without_building: true,
    xctestrun: xctestrun_path,
    result_bundle: true,
    # settings for XML test report generation via `trainer`
    output_types: '',
    fail_build: false
  )

  trainer(
    path: lane_context[SharedValues::SCAN_GENERATED_XCRESULT_PATH],
    fail_build: true,
    output_remove_retry_attempts: true
  )
end

# -----------------------------------------------------------------------------------
# Generates Prototype Build Version Numbers in a Buildkite-specific way
# -----------------------------------------------------------------------------------
def generate_prototype_build_number
  if ENV.key?('BUILDKITE')
    commit = ENV.fetch('BUILDKITE_COMMIT')[0, 7]
    branch = ENV.fetch('BUILDKITE_BRANCH')
    pr_num = ENV.fetch('BUILDKITE_PULL_REQUEST')

    pr_num == 'false' ? "#{branch}-#{commit}" : "pr#{pr_num}-#{commit}"
  else
    repo = Git.open(PROJECT_ROOT_FOLDER)
    commit = repo.current_branch
    branch = repo.revparse('HEAD')[0, 7]

    "#{branch}-#{commit}"
  end
end

# -----------------------------------------------------------------------------------
# Raises an error if Sentry is not installed
# -----------------------------------------------------------------------------------
def ensure_sentry_installed
  # This is an action provided by the Sentry Fastlane plugin that verifies the
  # CLI is installed and its version is compatible with the plugin's
  # expectation.
  sentry_check_cli_installed
end

# -----------------------------------------------------------------------------------
# Kicks off a Buildkite build
# -----------------------------------------------------------------------------------
def trigger_buildkite_release_build(branch:, beta:)
  buildkite_trigger_build(
    buildkite_organization: 'automattic',
    buildkite_pipeline: 'woocommerce-ios',
    branch: branch,
    environment: { BUILDKITE_BETA_RELEASE: beta },
    pipeline_file: 'release-builds.yml'
  )
end

def inject_buildkite_analytics_environment(xctestrun_path:)
  require 'plist'

  xctestrun = Plist.parse_xml(xctestrun_path)
  xctestrun['TestConfigurations'].each do |configuration|
    configuration['TestTargets'].each do |target|
      TEST_ANALYTICS_ENVIRONMENT.each do |key|
        value = ENV.fetch(key)
        next if value.nil?

        target['EnvironmentVariables'][key] = value
      end
    end
  end

  File.write(xctestrun_path, Plist::Emit.dump(xctestrun))
end

# -----------------------------------------------------------------------------------
# Version Methods
# -----------------------------------------------------------------------------------

# Returns the release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
#
def release_version_current
  # Read the current release version from the .xcconfig file and parse it into an AppVersion object
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_release_version)
  # Return the formatted release version
  VERSION_FORMATTER.release_version(current_version)
end

#  Returns the next release version of the app in the format `1.2` or `1.2.3` if it is a hotfix
#
def release_version_next
  # Read the current release version from the .xcconfig file and parse it into an AppVersion object
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_release_version)
  # Calculate the next release version
  next_calculated_release_version = VERSION_CALCULATOR.next_release_version(version: current_version)
  # Return the formatted release version
  VERSION_FORMATTER.release_version(next_calculated_release_version)
end

# Returns the current build code of the app
#
def build_code_current
  # Read the current build code from the .xcconfig file and parse it into an AppVersion object
  # The AppVersion is used because WCiOS uses the four part (1.2.3.4) build code format, so the version
  # calculator can be used to calculate the next four-part version
  version = VERSION_FORMATTER.parse(VERSION_FILE.read_build_code(attribute_name: BUILD_CODE_KEY))
  # Return the formatted build code
  BUILD_CODE_FORMATTER.build_code(version: version)
end

# Returns the build code of the app for the code freeze. It is the release version name plus sets the build number to 0
#
def build_code_code_freeze
  # Read the current build code from the .xcconfig file and parse it into an AppVersion object
  # The AppVersion is used because WCiOS uses the four part (1.2.3.4) build code format, so the version
  # calculator can be used to calculate the next four-part version
  release_version_current = VERSION_FORMATTER.parse(VERSION_FILE.read_release_version)
  # Calculate the next release version, which will be used as the basis of the new build code
  build_code_code_freeze = VERSION_CALCULATOR.next_release_version(version: release_version_current)
  # Return the formatted build code
  BUILD_CODE_FORMATTER.build_code(version: build_code_code_freeze)
end

# Returns the next build code of the app
#
def build_code_next
  # Read the current build code from the .xcconfig file and parse it into an AppVersion object
  # The AppVersion is used because WCiOS uses the four part (1.2.3.4) build code format, so the version
  # calculator can be used to calculate the next four-part version
  build_code_current = VERSION_FORMATTER.parse(VERSION_FILE.read_build_code(attribute_name: BUILD_CODE_KEY))
  # Calculate the next build code
  build_code_next = VERSION_CALCULATOR.next_build_number(version: build_code_current)
  # Return the formatted build code
  BUILD_CODE_FORMATTER.build_code(version: build_code_next)
end

def release_is_hotfix?
  # Read the current release version from the .xcconfig file and parse it into an AppVersion object
  current_version = VERSION_FORMATTER.parse(VERSION_FILE.read_release_version)
  # Calculate and return whether the release version is a hotfix
  VERSION_CALCULATOR.release_is_hotfix?(version: current_version)
end

def commit_version_bump
  git_commit(
    path: PUBLIC_CONFIG_FILE,
    message: 'Bump version number',
    allow_nothing_to_commit: false
  )
end

def buildkite_ci?
  ENV.fetch('BUILDKITE', false)
end

def prompt_user_for_app_store_connect_credentials
  require 'credentials_manager'

  # If Fastlane cannot instantiate a user, it will ask the caller for the email.
  # Once we have it, we can set it as `FASTLANE_USER` in the environment (which has lifecycle limited to this call) so that the next commands will
  # already have access to it.
  # Note that if the user is already available to `AccountManager`, setting it in the environment is redundant, but Fastlane doesn't provide a way
  # to check it so we have to do it anyway.
  ENV['FASTLANE_USER'] = CredentialsManager::AccountManager.new.user
end

def override_default_release_branch(version)
  success = Fastlane::Helper::GitHelper.checkout_and_pull(release: version)
  UI.user_error!("Release branch for version #{version} doesn't exist. Abort.") unless success

  UI.message("Checked out branch `#{git_branch}` as requested by user.\n")
end

# https://buildkite.com/docs/test-analytics/ci-environments
TEST_ANALYTICS_ENVIRONMENT = %w[
  BUILDKITE_ANALYTICS_TOKEN
  BUILDKITE_BUILD_ID
  BUILDKITE_BUILD_NUMBER
  BUILDKITE_JOB_ID
  BUILDKITE_BRANCH
  BUILDKITE_COMMIT
  BUILDKITE_MESSAGE
  BUILDKITE_BUILD_URL
].freeze

# -----------------------------------------------------------------------------------
# Release Management Utils
# -----------------------------------------------------------------------------------
def create_release_management_pull_request(base_branch:, title:)
  create_pull_request(
    api_token: get_required_env('GITHUB_TOKEN'),
    repo: GITHUB_REPO,
    title: title,
    head: Fastlane::Helper::GitHelper.current_git_branch,
    base: base_branch,
    labels: 'Releases'
  )
end

def ensure_git_branch_is_release_branch
  # Verify that the current branch is a release branch. Notice that `ensure_git_branch` expects a RegEx parameter
  ensure_git_branch(branch: '^release/')
end

def check_pods_references
  result = ios_check_beta_deps(lockfile: File.join(PROJECT_ROOT_FOLDER, 'Podfile.lock'))

  style = result[:pods].nil? || result[:pods].empty? ? 'success' : 'warning'
  message = "### Checking Internal Dependencies are all on a **stable** version\n\n#{result[:message]}"
  buildkite_annotate(context: 'pods-check', style: style, message: message) if is_ci
end
